(define remove-applic-lambda-nil
  (lambda (e)
    (let ((tag (car e)))
      (cond ((eq? tag 'if3)
             (let ((test (cadr e))
                   (dit (caddr e))
                   (dif (cadddr e)))
               `(if3 ,(remove-applic-lambda-nil test)
                     ,(remove-applic-lambda-nil dit)
                     ,(remove-applic-lambda-nil dif))))
            ((eq? tag 'or) `(or ,(map remove-applic-lambda-nil (cadr e))))
            ((eq? tag 'define)
             (let ((var (cadr e))
                   (val (caddr e)))
               `(define ,var ,(remove-applic-lambda-nil val))))
            ((eq? tag 'set)
             (let ((var (cadr e))
                   (val (caddr e)))
               `(set ,var ,(remove-applic-lambda-nil val))))
            ((eq? tag 'seq) `(seq ,@(map remove-applic-lambda-nil (cadr e))))
            ((eq? tag 'lambda-simple)
             (let ((params (cadr e))
                   (body (caddr e)))
               `(lambda-simple ,params ,(remove-applic-lambda-nil body))))
            ((eq? tag 'lambda-opt)
             (let ((params (cadr e))
                   (opt-param (caddr e))
                   (body (cadddr e)))
               `('lambda-opt ,params ,opt-param ,(remove-applic-lambda-nil body))))
            ((eq? tag 'applic)
             (let ((f (cadr e))
                   (args (caddr e)))
               (if (and (eq? (car f) 'lambda-simple)
                        (null? (cadr f)))
                   (remove-applic-lambda-nil (caddr f))
                   `(applic ,(remove-applic-lambda-nil f)
                            ,@(map remove-applic-lambda-nil args)))))
            (else e)))))

(define box-set
  (lambda (e) e))


(define pe->lex-pe
  (lambda (e) e))

(define annotate-tc
  (lambda (e) e)
  )

(define bound?
  (lambda (e param depth)
    (let ((tag (car e)))
      (cond ((eq? tag 'var)
             (let ((res (and (> depth 0)
                        (eq? (cadr e) param))))
              (begin (display e)
                     (display " ")
                     (display depth)
                     (newline)
                     (if res (begin
                               (set-car! e 'box-get)
                               (set-cdr! e (list `(var ,(cadr e))))))
                     res)))
            ((eq? tag 'if3)
             (let ((test (cadr e))
                   (dit (caddr e))
                   (dif (cadddr e)))
               (or (bound? test param depth)
                   (bound? dit param depth)
                   (bound? dif param depth))))
            ((eq? tag 'or) (a-ormap (lambda (el) (bound? el param depth)) (cadr e)))
            ((eq? tag 'define)
             (let ((var (cadr e))
                   (val (caddr e)))
               (bound? val param depth)))
            ((eq? tag 'set)
             (let* ((var (cadr e))
                    (val (caddr e))
                    (result-var (and (> depth 0)
                                     (eq? (cadr var) param)))
                    (result-val (bound? val param depth)))
               (if result-var
                   (set-car! e 'box-set))
               (display e) (newline)
               result-val))
            ((eq? tag 'seq) (a-ormap (lambda (el) (bound? el param depth)) (cadr e)))
            ((eq? tag 'lambda-simple)
             (let* ((params (cadr e))
                    (body (caddr e)))
               (lambda-bound? params body param depth)))
            ((eq? tag 'lambda-opt)
             (let* ((params (cadr e))
                    (opt-param (caddr e))
                    (body (cadddr e)))
               (lambda-bound? params body param depth)))
            ((eq? tag 'applic)
             (let ((f (cadr e))
                   (args (caddr e)))
               (or (bound? f param depth)
                   (a-ormap (lambda (el) (bound? el param depth)) args))))
            (else #f)))))

(define lambda-bound?
  (lambda (params body param depth)
    (let ((result
           (bound? body param
             (if (member param params)
                 0
                 (+ depth 1)))))
      (if (and result (member param params))
          (begin
            (let ((first (car body)))
              (if (eq? first 'seq)
                  (set-cdr! body `(((set (var ,param) (box (var ,param))) ,@(cadr body))))
                  (begin (set-car! body 'seq)
                    (set-cdr! body `(((set (var ,param) (box (var ,param))) ,(cons first (cdr body))))))))
            (display body) (newline)))
      result)))

(define a-ormap
  (lambda (f l)
    (fold-left (lambda (acc curr) (or acc curr))
      #f
      (map f l))))
