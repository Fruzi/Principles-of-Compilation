(define remove-applic-lambda-nil
  (lambda (e)
    (let ((tag (car e)))
      (cond ((eq? tag 'if3)
             (let ((test (cadr e))
                   (dit (caddr e))
                   (dif (cadddr e)))
               `(if3 ,(remove-applic-lambda-nil test)
                     ,(remove-applic-lambda-nil dit)
                     ,(remove-applic-lambda-nil dif))))
            ((eq? tag 'or) `(or ,(map remove-applic-lambda-nil (cadr e))))
            ((eq? tag 'define)
             (let ((var (cadr e))
                   (val (caddr e)))
               `(define ,var ,(remove-applic-lambda-nil val))))
            ((eq? tag 'set)
             (let ((var (cadr e))
                   (val (caddr e)))
               `(set ,var ,(remove-applic-lambda-nil val))))
            ((eq? tag 'seq) `(seq ,(map remove-applic-lambda-nil (cadr e))))
            ((eq? tag 'lambda-simple)
             (let ((params (cadr e))
                   (body (caddr e)))
               `(lambda-simple ,params ,(remove-applic-lambda-nil body))))
            ((eq? tag 'lambda-opt)
             (let ((params (cadr e))
                   (opt-param (caddr e))
                   (body (cadddr e)))
               `(lambda-opt ,params ,opt-param ,(remove-applic-lambda-nil body))))
            ((eq? tag 'applic)
             (let ((f (cadr e))
                   (args (caddr e)))
               (if (and (eq? (car f) 'lambda-simple)
                        (null? (cadr f))
                        (null? args))
                   (remove-applic-lambda-nil (caddr f))
                   `(applic ,(remove-applic-lambda-nil f)
                            ,(map remove-applic-lambda-nil args)))))
            (else e)))))

(define box-set
  (lambda (e)
    (let ((tag (car e)))
      (cond ((eq? tag 'if3)
             (let ((test (cadr e))
                   (dit (caddr e))
                   (dif (cadddr e)))
               `(if3 ,(box-set test)
                     ,(box-set dit)
                     ,(box-set dif))))
            ((eq? tag 'or) `(or ,(map box-set (cadr e))))
            ((eq? tag 'define)
             (let ((var (cadr e))
                   (val (caddr e)))
                `(define ,var ,(box-set val))))
            ((eq? tag 'set)
             (let ((var (cadr e))
                   (val (caddr e)))
               `(set ,var ,(box-set val))))
            ((eq? tag 'seq) `(seq ,(map box-set (cadr e))))
            ((eq? tag 'lambda-simple)
             (let ((params (cadr e))
                   (body (caddr e)))
               `(lambda-simple ,params
                  ,(fold-left (lambda (acc param) (box-set-el acc param))
                      (box-set body) (reverse params)))))
            ((eq? tag 'lambda-opt)
             (let* ((params (cadr e))
                    (opt-param (caddr e))
                    (all-params (append params (list opt-param)))
                    (body (cadddr e)))
               `(lambda-opt ,params ,opt-param
                  ,(fold-left (lambda (acc param) (box-set-el acc param))
                      (box-set body) (reverse all-params)))))
            ((eq? tag 'applic)
             (let ((f (cadr e))
                   (args (caddr e)))
               `(applic ,(box-set f) ,(map box-set args))))
            (else e)))))

(define box-set-el
  (lambda (body el)
    ;(printf "body: ~a el: ~a\n" body el)
    (let ((bound-res (bound? body el 0))
          (get-res (has-get? body el))
          (set-res (has-set? body el)))
      ;(printf "bound: ~a has-get: ~a has-set: ~a\n\n" bound-res get-res set-res)
      (if (and bound-res get-res set-res)
          (add-box-set (replace-gets-sets body el) el)
          body))))

(define pe->lex-pe
  (lambda (e)
    (pe->lex-pe-2 (pe->lex-pe-1 e))))

(define pe->lex-pe-1
  (lambda (e)
    (let ((tag (car e)))
      (cond ((eq? tag 'if3)
             (let ((test (cadr e))
                   (dit (caddr e))
                   (dif (cadddr e)))
               `(if3 ,(pe->lex-pe-1 test)
                     ,(pe->lex-pe-1 dit)
                     ,(pe->lex-pe-1 dif))))
            ((eq? tag 'or) `(or ,(map pe->lex-pe-1 (cadr e))))
            ((eq? tag 'define)
             (let ((var (cadr e))
                   (val (caddr e)))
                `(define ,(pe->lex-pe-1 var) ,(pe->lex-pe-1 val))))
            ((eq? tag 'set)
             (let ((var (cadr e))
                   (val (caddr e)))
               `(set ,var ,(pe->lex-pe-1 val))))
            ((eq? tag 'seq) `(seq ,(map pe->lex-pe-1 (cadr e))))
            ((eq? tag 'lambda-simple)
             (let* ((params (cadr e))
                    (body (caddr e))
                    (enumerated-params (map (lambda (p n) (cons p n)) params (enumerate params))))
               `(lambda-simple ,params
                  ,(fold-left (lambda (acc param) (var->lex-var acc (car param) (cdr param) 0))
                     (pe->lex-pe-1 body) enumerated-params))))
            ((eq? tag 'lambda-opt)
             (let* ((params (cadr e))
                    (opt-param (caddr e))
                    (all-params (append params (list opt-param)))
                    (body (cadddr e))
                    (enumerated-params (map (lambda (p n) (cons p n)) all-params (enumerate all-params))))
               `(lambda-opt ,params ,opt-param
                  ,(fold-left (lambda (acc param) (var->lex-var acc (car param) (cdr param) 0))
                     (pe->lex-pe-1 body) enumerated-params))))
            ((eq? tag 'applic)
             (let ((f (cadr e))
                   (args (caddr e)))
               `(applic ,(pe->lex-pe-1 f) ,(map pe->lex-pe-1 args))))
            ((eq? tag 'box)
             `(box ,(pe->lex-pe-1 (cadr e))))
            ((eq? tag 'box-get)
             `(box-get ,(pe->lex-pe-1 (cadr e))))
            ((eq? tag 'box-set)
             (let ((var (cadr e))
                   (val (caddr e)))
               `(box-set ,var ,(pe->lex-pe-1 val))))
            (else e)))))

(define pe->lex-pe-2
  (lambda (e)
    (let ((tag (car e)))
      (cond ((eq? tag 'var)
             `(fvar ,(cadr e)))
            ((eq? tag 'if3)
             (let ((test (cadr e))
                   (dit (caddr e))
                   (dif (cadddr e)))
               `(if3 ,(pe->lex-pe-2 test)
                     ,(pe->lex-pe-2 dit)
                     ,(pe->lex-pe-2 dif))))
            ((eq? tag 'or) `(or ,(map pe->lex-pe-2 (cadr e))))
            ((eq? tag 'define)
             (let ((var (cadr e))
                   (val (caddr e)))
                `(define ,(pe->lex-pe-2 var) ,(pe->lex-pe-2 val))))
            ((eq? tag 'set)
             (let ((var (cadr e))
                   (val (caddr e)))
               `(set ,(pe->lex-pe-2 var) ,(pe->lex-pe-2 val))))
            ((eq? tag 'seq) `(seq ,(map pe->lex-pe-2 (cadr e))))
            ((eq? tag 'lambda-simple)
             (let ((params (cadr e))
                   (body (caddr e)))
               `(lambda-simple ,params ,(pe->lex-pe-2 body))))
            ((eq? tag 'lambda-opt)
             (let ((params (cadr e))
                   (opt-param (caddr e))
                   (body (cadddr e)))
               `(lambda-opt ,params ,opt-param ,(pe->lex-pe-2 body))))
            ((eq? tag 'applic)
             (let ((f (cadr e))
                   (args (caddr e)))
               `(applic ,(pe->lex-pe-2 f) ,(map pe->lex-pe-2 args))))
            ((eq? tag 'box)
             `(box ,(pe->lex-pe-2 (cadr e))))
            ((eq? tag 'box-get)
             `(box-get ,(pe->lex-pe-2 (cadr e))))
            ((eq? tag 'box-set)
             (let ((var (cadr e))
                   (val (caddr e)))
               `(box-set ,(pe->lex-pe-2 var) ,(pe->lex-pe-2 val))))
            (else e)))))

(define annotate-tc
  (lambda (e)
    (annotate-tc-1 e #f)))

(define annotate-tc-1
  (lambda (e intp)
    (let ((tag (car e)))
      (cond ((eq? tag 'if3)
             (let ((test (cadr e))
                   (dit (caddr e))
                   (dif (cadddr e)))
               `(if3 ,(annotate-tc-1 test #f)
                     ,(annotate-tc-1 dit intp)
                     ,(annotate-tc-1 dif intp))))
            ((eq? tag 'or) `(or (,@(map (lambda (el) (annotate-tc-1 el #f)) (without-last (cadr e)))
                                ,(annotate-tc-1 (last (cadr e)) intp))))
            ((eq? tag 'define)
             (let ((var (cadr e))
                   (val (caddr e)))
                `(define ,(annotate-tc-1 var #f) ,(annotate-tc-1 val #f))))
            ((eq? tag 'set)
             (let ((var (cadr e))
                   (val (caddr e)))
               `(set ,(annotate-tc-1 var #f) ,(annotate-tc-1 val #f))))
            ((eq? tag 'seq) `(seq (,@(map (lambda (el) (annotate-tc-1 el #f)) (without-last (cadr e)))
                                  ,(annotate-tc-1 (last (cadr e)) intp))))
            ((eq? tag 'lambda-simple)
             (let ((params (cadr e))
                   (body (caddr e)))
               `(lambda-simple ,params ,(annotate-tc-1 body #t))))
            ((eq? tag 'lambda-opt)
             (let ((params (cadr e))
                   (opt-param (caddr e))
                   (body (cadddr e)))
               `(lambda-opt ,params ,opt-param ,(annotate-tc-1 body #t))))
            ((eq? tag 'applic)
             (let ((f (cadr e))
                   (args (caddr e)))
               (if intp
                   `(tc-applic ,(annotate-tc-1 f #f) ,(map (lambda (el) (annotate-tc-1 el #f)) args))
                   `(applic ,(annotate-tc-1 f #f) ,(map (lambda (el) (annotate-tc-1 el #f)) args)))))
            ((eq? tag 'box-get)
             `(box-get ,(annotate-tc-1 (cadr e) #f)))
            ((eq? tag 'box-set)
             (let ((var (cadr e))
                   (val (caddr e)))
               `(box-set ,(annotate-tc-1 var #f) ,(annotate-tc-1 val #f))))
            (else e)))))

(define bound?
  (lambda (e v depth)
    (let ((tag (car e)))
      (cond ((eq? tag 'var)
             (and (> depth 0)
                  (eq? (cadr e) v)))
            ((eq? tag 'if3)
             (let ((test (cadr e))
                   (dit (caddr e))
                   (dif (cadddr e)))
               (or (bound? test v depth)
                   (bound? dit v depth)
                   (bound? dif v depth))))
            ((eq? tag 'or) (ormap (lambda (el) (bound? el v depth)) (cadr e)))
            ((eq? tag 'define)
             (let ((var (cadr e))
                   (val (caddr e)))
               (bound? val v depth)))
            ((eq? tag 'set)
             (let ((var (cadr e))
                   (val (caddr e)))
               (or (bound? var v depth)
                   (bound? val v depth))))
            ((eq? tag 'seq) (ormap (lambda (el) (bound? el v depth)) (cadr e)))
            ((eq? tag 'lambda-simple)
             (let ((params (cadr e))
                   (body (caddr e)))
               (if (not (member v params))
                   (bound? body v (+ depth 1))
                   #f)))
            ((eq? tag 'lambda-opt)
             (let ((params (cadr e))
                   (opt-param (caddr e))
                   (body (cadddr e)))
               (if (not (or (member v params) (eq? v opt-param)))
                   (bound? body v (+ depth 1))
                   #f)))
            ((eq? tag 'applic)
             (let ((f (cadr e))
                   (args (caddr e)))
               (or (bound? f v depth)
                   (ormap (lambda (el) (bound? el v depth)) args))))
            ((eq? tag 'box)
             (bound? (cadr e) v depth))
            ((eq? tag 'box-set)
             (let ((var (cadr e))
                   (val (caddr e)))
               (or (bound? var v depth)
                   (bound? val v depth))))
            ((eq? tag 'box-get)
             (bound? (cadr e) v depth))
            (else #f)))))

(define has-get?
  (lambda (e v)
    ;(printf "e: ~a v: ~a\n" e v)
    (let ((tag (car e)))
      (cond ((eq? tag 'var)
             (eq? (cadr e) v))
            ((eq? tag 'if3)
             (let ((test (cadr e))
                   (dit (caddr e))
                   (dif (cadddr e)))
               (or (has-get? test v)
                   (has-get? dit v)
                   (has-get? dif v))))
            ((eq? tag 'or) (ormap (lambda (el) (has-get? el v)) (cadr e)))
            ((eq? tag 'define)
             (let ((var (cadr e))
                   (val (caddr e)))
               (has-get? val v)))
            ((eq? tag 'set)
             (let ((var (cadr e))
                   (val (caddr e)))
               (has-get? val v)))
            ((eq? tag 'seq) (ormap (lambda (el) (has-get? el v)) (cadr e)))
            ((eq? tag 'lambda-simple)
             (let ((params (cadr e))
                   (body (caddr e)))
               (if (not (member v params))
                   (has-get? body v)
                   #f)))
            ((eq? tag 'lambda-opt)
             (let ((params (cadr e))
                   (opt-param (caddr e))
                   (body (cadddr e)))
               (if (not (or (member v params) (eq? v opt-param)))
                   (has-get? body v)
                   #f)))
            ((eq? tag 'applic)
             (let ((f (cadr e))
                   (args (caddr e)))
               (or (has-get? f v)
                   (ormap (lambda (el) (has-get? el v)) args))))
            ((eq? tag 'box)
             (has-get? (cadr e) v))
            ((eq? tag 'box-set)
             (let ((var (cadr e))
                   (val (caddr e)))
               (has-get? val v)))
            ((eq? tag 'box-get)
             (has-get? (cadr e) v))
            (else #f)))))

(define has-set?
  (lambda (e v)
    (let ((tag (car e)))
      (cond ((eq? tag 'if3)
             (let ((test (cadr e))
                   (dit (caddr e))
                   (dif (cadddr e)))
               (or (has-set? test v)
                   (has-set? dit v)
                   (has-set? dif v))))
            ((eq? tag 'or) (ormap (lambda (el) (has-set? el v)) (cadr e)))
            ((eq? tag 'define)
             (let ((var (cadr e))
                   (val (caddr e)))
               (has-set? val v)))
            ((eq? tag 'set)
             (let ((var (cadr e))
                   (val (caddr e)))
               (or (eq? (cadr var) v)
                   (has-set? val v))))
            ((eq? tag 'seq) (ormap (lambda (el) (has-set? el v)) (cadr e)))
            ((eq? tag 'lambda-simple)
             (let ((params (cadr e))
                   (body (caddr e)))
               (if (not (member v params))
                   (has-set? body v)
                   #f)))
            ((eq? tag 'lambda-opt)
             (let ((params (cadr e))
                   (opt-param (caddr e))
                   (body (cadddr e)))
               (if (not (or (member v params) (eq? v opt-param)))
                   (has-set? body v)
                   #f)))
            ((eq? tag 'applic)
             (let ((f (cadr e))
                   (args (caddr e)))
               (or (has-set? f v)
                   (ormap (lambda (el) (has-set? el v)) args))))
            ((eq? tag 'box-set)
             (let ((var (cadr e))
                   (val (caddr e)))
               (or (eq? (cadr var) v)
                   (has-set? val v))))
            (else #f)))))

(define replace-gets-sets
  (lambda (e v)
    (let ((tag (car e)))
      (cond ((eq? tag 'var)
             (if (eq? (cadr e) v)
                 `(box-get ,e)
                 e))
            ((eq? tag 'if3)
             (let ((test (cadr e))
                   (dit (caddr e))
                   (dif (cadddr e)))
               `(if3 ,(replace-gets-sets test v)
                     ,(replace-gets-sets dit v)
                     ,(replace-gets-sets dif v))))
            ((eq? tag 'or) `(or ,(map (lambda (el) (replace-gets-sets el v)) (cadr e))))
            ((eq? tag 'define)
             (let ((var (cadr e))
                   (val (caddr e)))
                `(define ,var ,(replace-gets-sets val v))))
            ((eq? tag 'set)
             (let ((var (cadr e))
                   (val (caddr e)))
               (if (eq? (cadr var) v)
                   `(box-set ,var ,(replace-gets-sets val v))
                   `(set ,var ,(replace-gets-sets val v)))))
            ((eq? tag 'seq) `(seq ,(map (lambda (el) (replace-gets-sets el v)) (cadr e))))
            ((eq? tag 'lambda-simple)
             (let ((params (cadr e))
                   (body (caddr e)))
               (if (not (member v params))
                   `(lambda-simple ,params ,(replace-gets-sets body v))
                   e)))
            ((eq? tag 'lambda-opt)
             (let ((params (cadr e))
                   (opt-param (caddr e))
                   (body (cadddr e)))
               (if (not (or (member v params) (eq? v opt-param)))
                   `(lambda-opt ,params ,opt-param ,(replace-gets-sets body v))
                   e)))
            ((eq? tag 'applic)
             (let ((f (cadr e))
                   (args (caddr e)))
               `(applic ,(replace-gets-sets f v) ,(map (lambda (el) (replace-gets-sets el v)) args))))
            ((eq? tag 'box-set)
             (let ((var (cadr e))
                   (val (caddr e)))
               `(box-set ,var ,(replace-gets-sets val v))))
            (else e)))))

(define add-box-set
  (lambda (body v)
    (if (eq? (car body) 'seq)
        `(seq ((set (var ,v) (box (var ,v))) ,@(cadr body)))
        `(seq ((set (var ,v) (box (var ,v))) ,body)))))

(define var->lex-var
  (lambda (e v minor depth)
    (let ((tag (car e)))
      (cond ((eq? tag 'var)
             (if (eq? (cadr e) v)
                 (if (= depth 0)
                     `(pvar ,(cadr e) ,minor)
                     `(bvar ,(cadr e) ,(- depth 1) ,minor))
                 e))
            ((eq? tag 'if3)
             (let ((test (cadr e))
                   (dit (caddr e))
                   (dif (cadddr e)))
               `(if3 ,(var->lex-var test v minor depth)
                     ,(var->lex-var dit v minor depth)
                     ,(var->lex-var dif v minor depth))))
            ((eq? tag 'or) `(or ,(map (lambda (el) (var->lex-var el v minor depth)) (cadr e))))
            ((eq? tag 'define)
             (let ((var (cadr e))
                   (val (caddr e)))
                `(define ,(var->lex-var var v minor depth) ,(var->lex-var val v minor depth))))
            ((eq? tag 'set)
             (let ((var (cadr e))
                   (val (caddr e)))
               `(set ,(var->lex-var var v minor depth) ,(var->lex-var val v minor depth))))
            ((eq? tag 'seq) `(seq ,(map (lambda (el) (var->lex-var el v minor depth)) (cadr e))))
            ((eq? tag 'lambda-simple)
             (let ((params (cadr e))
                   (body (caddr e)))
               (if (not (member v params))
                   `(lambda-simple ,params ,(var->lex-var body v minor (+ depth 1)))
                   e)))
            ((eq? tag 'lambda-opt)
             (let ((params (cadr e))
                   (opt-param (caddr e))
                   (body (cadddr e)))
               (if (not (or (member v params) (eq? v opt-param)))
                   `(lambda-opt ,params ,opt-param ,(var->lex-var body v minor (+ depth 1)))
                   e)))
            ((eq? tag 'applic)
             (let ((f (cadr e))
                   (args (caddr e)))
               `(applic ,(var->lex-var f v minor depth) ,(map (lambda (el) (var->lex-var el v minor depth)) args))))
            ((eq? tag 'box)
             `(box ,(var->lex-var (cadr e) v minor depth)))
            ((eq? tag 'box-get)
             `(box-get ,(var->lex-var (cadr e) v minor depth)))
            ((eq? tag 'box-set)
             (let ((var (cadr e))
                   (val (caddr e)))
               `(box-set ,(var->lex-var var v minor depth) ,(var->lex-var val v minor depth))))
            (else e)))))

(define without-last
    (lambda (l)
      (if (not (pair? (cdr l)))
          '()
          (cons (car l) (without-last (cdr l))))))

(define last
    (lambda (l)
      (if (not (pair? (cdr l)))
          (car l)
          (last (cdr l)))))

